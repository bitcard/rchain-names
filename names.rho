new
  basket,
  records,
  updateCh,
  createCh,
  changePriceCh,
  entry,
  entryUriCh,
  recordsUriCh,
  updateUriCh,
  priceNonceCh,
  publicKeyCh,
  recipientAddressCh,
  priceCh,
  registryLookup(`rho:registry:lookup`),
  secpVerify(`rho:crypto:secp256k1Verify`),
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`),
  lookup(`rho:registry:lookup`),
  blake2b256(`rho:crypto:blake2b256Hash`),
  revAddress(`rho:rev:address`)
in {

  // 1 REV
  priceCh!(1500000000) |

  priceNonceCh!(NONCE) |
  publicKeyCh!(PUBLIC_KEY) |
  recipientAddressCh!(ADDRESS) |

  // Remove the following line (GENESIS....) if you don't want prereserved names
  GENESIS_OPERATIONS
  records!({}) |

  // Change the price of record purchase
  contract changePriceCh(@payload, return) = {
    stdout!("changePriceCh") |
    new hashCh, verifySignatureChangePriceCh in {
      for (@priceNonce <- priceNonceCh; @publicKey <- publicKeyCh) {
        publicKeyCh!(publicKey) |
        blake2b256!(
          priceNonce.toUtf8Bytes(),
          *hashCh
        ) |
        for (@hash <- hashCh) {
          secpVerify!(
            hash,
            payload.get("signature").hexToBytes(),
            publicKey.hexToBytes(),
            *verifySignatureChangePriceCh
          )
        } |
        for (@result <- verifySignatureChangePriceCh) {
          match result {
            true => {
              for (price <- priceCh) {
                return!(true) |
                priceCh!(payload.get("price")) |
                priceNonceCh!(payload.get("nonce"))
              }
            }
            false => {
              return!("error: Invalid signature, could not change price") |
              priceNonceCh!(priceNonce)
            }
          }
        }
      }
    }
  } |


  // Update a record
  contract updateCh(@record, return) = {
    new hashCh, verifySignatureCh in {
      for (current <- records) {
        match *current.contains(record.get("name")) {
          true => {
            match *current.get(record.get("name")) {
              registryUri => {
                new recordCh in {
                  lookup!(registryUri, *recordCh) |
                  for (currentRecord <- recordCh) {
                    blake2b256!(
                      *currentRecord.get("nonce").toUtf8Bytes(),
                      *hashCh
                    ) |
                    for (@hash <- hashCh) {
                      secpVerify!(
                        hash,
                        record.get("signature").hexToBytes(),
                        *currentRecord.get("publicKey").hexToBytes(),
                        *verifySignatureCh
                      ) |
                      for (@result <- verifySignatureCh) {
                        match result {
                          true => {
                            return!(true) |
                            new recordUriCh in {
                              insertArbitrary!(record, *recordUriCh) |
                              for (recordUri <- recordUriCh) {
                                records!(
                                  *current
                                    .delete(record.get("name"))
                                    .set(record.get("name"), *recordUri)
                                )
                              }
                            }
                          }
                          false => {
                            return!("error: signature invalid") |
                            records!(*current)
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          false => {
            return!("error: name not found") |
            records!(*current)
          }
        }
      }
    }
  } |

  // create a record
  contract createCh(record, paymentDataCh) = {
    stdout!("createCh") |
    for (current <<- records) {
      match *current.contains(*record.get("name")) {
        true => {
          paymentDataCh!("error: name " ++ *record.get("name") ++ " already taken") |
          records!(*current)
        }
        false => {
          new revVaultCh,
            payRevReturnCh,
            payRevDataCh,
            revVaultCh,
            revAddressCh,
            paymentDoneCh,
            performCashingCh,
            RevAddress(`rho:rev:address`)
          in {
            for (@price <<- priceCh; @recipientAddress <<- recipientAddressCh) {
              registryLookup!(`rho:rchain:revVault`, *revVaultCh) |

              /*
                Create a vault/purse that is just used once (purse)
              */
              for(@(_, *revVault) <- revVaultCh) {
                new unf, purseRevAddrCh, purseAuthKeyCh, purseVaultCh, revAddressCh, paymentDoneCh in {
                  revAddress!("fromUnforgeable", *unf, *purseRevAddrCh) |
                  revVault!("unforgeableAuthKey", *unf, *purseAuthKeyCh) |
                  for (@purseAuthKey <- purseAuthKeyCh; @purseRevAddr <- purseRevAddrCh) {
                    stdout!({"new purse rev addr": purseRevAddr, "purse authKey": purseAuthKey}) |
                    revVault!("findOrCreate", purseRevAddr, *purseVaultCh) |
                    for (@(true, *vault) <- purseVaultCh) {
                      /*
                        Send payment data to client
                      */
                      paymentDataCh!(
                        (
                          {                         
                            "purseRevAddr": purseRevAddr,
                            "price": price,
                          },
                          *paymentDoneCh
                        )
                      ) |
                      for (@(resp, returnCh2) <- paymentDoneCh) {
                        new recipientVaultCh, vaultTo, revVaultkeyCh in {
                          match (purseRevAddr, recipientAddress, price) {
                            (revAddrFrom, revAddrTo, amount) => {
                              revVault!("findOrCreate", revAddrFrom, *recipientVaultCh) |
                              for (@vault <- recipientVaultCh) {
                                match vault {
                                  (true, vault) => {
                                    new resultCh in {
                                      @vault!("transfer", revAddrTo, amount, purseAuthKey, *resultCh) |
                                      for (@result <- resultCh) {
                                        stdout!(("Trying to transfer ", price, "from", revAddrFrom, "to", revAddrTo)) |
                                        stdout!(result) |
                                        match result {
                                          (true , Nil) => {
                                            new recordUriCh in {
                                              insertArbitrary!(*record, *recordUriCh) |
                                              for (r <- records; recordUri <- recordUriCh) {
                                                stdout!("success: record " ++ *record.get("name") ++ " created") |
                                                @returnCh2!(true) |
                                                records!(*current.set(*record.get("name"), *recordUri))
                                              }
                                            }
                                          }
                                          (false, err) => @returnCh2!(err)
                                        }
                                      }
                                    }
                                  }
                                  err => { payRevReturnCh!(err) }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  contract entry(@(action, return)) = {
    stdout!(action) |
    match action.get("type") {
      "CREATE" => {
        match action.get("payload") {
          {
            "publicKey": String,
            "nonce": String,
            "address": String,
            "name": String,
            "servers": _
          } => {
            createCh!(action.get("payload"), return)
          }
          _ => {
            @return!("Invalid payload")
          }
        }
      }
      "UPDATE" => {
        match action.get("payload") {
          {
            "signature": String,
            "publicKey": String,
            "nonce": String,
            "address": String,
            "name": String,
            "servers": _
          } => {
            updateCh!(action.get("payload"), return)
          }
          _ => {
            @return!("Invalid payload")
          }
        }
      }
      "CHANGE_PRICE" => {
        match action.get("payload") {
          {
            "signature": String,
            "price": Int,
            "nonce": String,
          } => {
            changePriceCh!(action.get("payload"), return)
          }
          _ => {
            @return!("Invalid payload")
          }
        }
      }
      "READ" => {
        for (current <<- records; priceNonce <<- priceNonceCh; price <<- priceCh) {
          @return!({
            "records": *current,
            "priceNonce": *priceNonce,
            "price": *price
          })
        }
      }
    }
  } |

  insertArbitrary!(*entry, *entryUriCh) |

  for (entryUri <- entryUriCh) {
    stdout!({
      "registryUri": *entryUri,
      "recordsUnforgeableName": *records
    }) |
    basket!({
      "registryUri": *entryUri,
      "recordsUnforgeableName": *records
    })
  }
}
