new
  basket,
  records,
  updateCh,
  createCh,
  changePriceCh,
  entry,
  hashname,
  verify,
  entryUriCh,
  recordsUriCh,
  updateUriCh,
  revAddrCh,
  verifySignatureCh,
  verifySignatureChangePriceCh,
  hashCh,
  RevVaultCh,
  priceNonceCh,
  publicKeyCh,
  recipientAddressCh,
  priceCh,
  rl(`rho:registry:lookup`),
  secpVerify(`rho:crypto:secp256k1Verify`),
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`),
  RevAddress(`rho:rev:address`),
  blake2b256(`rho:crypto:blake2b256Hash`)
in {

  // 1 REV
  priceCh!(100000000) |

  priceNonceCh!(NONCE) |
  publicKeyCh!(PUBLIC_KEY) |
  recipientAddressCh!(ADDRESS) |

  // Send an initially empty map
  records!(GENESIS_RECORDS_MAP) |

  // Change the price of record purchase
  contract changePriceCh(@payload, return) = {
    for (@priceNonce <- priceNonceCh; @publicKey <- publicKeyCh) {
      stdout!("priceNonce " ++ priceNonce) |
      stdout!("publicKey " ++ publicKey) |
      stdout!("signature " ++ payload.get("signature")) |
      publicKeyCh!(publicKey) |
      blake2b256!(
        priceNonce.toUtf8Bytes(),
        *hashCh
      ) |
      for (@hash <- hashCh) {
        secpVerify!(
          hash,
          payload.get("signature").hexToBytes(),
          publicKey.hexToBytes(),
          *verifySignatureChangePriceCh
        )
      } |
      for (@result <- verifySignatureChangePriceCh) {
        stdout!(result) |
        match result {
          true => {
            for (price <- priceCh) {
              stdout!("Price changed successfully to new value") |
              stdout!(payload.get("price")) |
              return!("Price changed successfully to new value") |
              priceCh!(payload.get("price")) |
              priceNonceCh!(payload.get("nonce"))
            }
          }
          false => {
            stdout!("error: Invalid signature, could not change price") |
            return!("error: Invalid signature, could not change price") |
            priceNonceCh!(priceNonce)
          }
        }
      }
    }
  } |


  // Update a record
  contract updateCh(@record, return) = {
    for (current <- records) {
      match *current.contains(record.get("name")) {
        true => {
          match *current.get(record.get("name")) {
            currentRecord => {
              blake2b256!(
                currentRecord.get("nonce").toUtf8Bytes(),
                *hashCh
              ) |
              for (@hash <- hashCh) {
                secpVerify!(
                  hash,
                  record.get("signature").hexToBytes(),
                  currentRecord.get("publicKey").hexToBytes(),
                  *verifySignatureCh
                ) |
                for (@result <- verifySignatureCh) {
                  match result {
                    true => {
                      return!(true) |
                      records!(*current.delete(record.get("name")).set(record.get("name"), record))
                    }
                    false => {
                      return!("error: signature invalid") |
                      records!(*current)
                    }
                  }
                }
              }
            }
          }
        }
        false => {
          return!("error: name not found") |
          records!(*current)
        }
      }
    }
  } |

  // create a record
  contract createCh(record, return) = {
    stdout!(1) |
    for (current <- records) {
      stdout!(2) |
      stdout!(*current) |
      match *current.contains(*record.get("name")) {
        true => {
          return!("error: name " ++ *record.get("name") ++ " already taken") |
          records!(*current)
        }
        false => {
          stdout!(3) |
          new payRevReturnCh, payRevDataCh in {
            // Payment handling
            for (@(pubKey, deployerId) <- payRevDataCh) {
              stdout!("pubKey  " ++ pubKey) |
              stdout!(deployerId) |
              RevAddress!("fromPublicKey", pubKey.hexToBytes(), *revAddrCh) |

              for (@revAddress <- revAddrCh; @price <- priceCh; @recipientAddress <- recipientAddressCh) {
                priceCh!(price) |
                rl!(`rho:rchain:revVault`, *RevVaultCh) |
                for (@(_, RevVault) <- RevVaultCh) {
                  new vaultCh, vaultTo, revVaultkeyCh,
                    deployId(`rho:rchain:deployId`)
                  in {
                    match (revAddress, recipientAddress, price) {
                      (revAddrFrom, revAddrTo, amount) => {
                        @RevVault!("findOrCreate", revAddrFrom, *vaultCh) |
                        @RevVault!("findOrCreate", revAddrTo, *vaultTo) |
                        @RevVault!("deployerAuthKey", deployerId, *revVaultkeyCh) |
                        for (@vault <- vaultCh; key <- revVaultkeyCh; _ <- vaultTo) {
                          match vault {
                            (true, vault) => {
                              new resultCh in {
                                @vault!("transfer", revAddrTo, amount, *key, *resultCh) |
                                for (@result <- resultCh) {
                                  stdout!(result) |
                                  match result {
                                    (true , Nil) => {
                                      payRevReturnCh!(true) |
                                      stdout!(*return) |
                                      stdout!("true nil")
                                    }
                                    (false, err) => payRevReturnCh!(err)
                                  }
                                }
                              }
                            }
                            err => { payRevReturnCh!(err) }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } |

            payRevDataCh!((*record.get("publicKey"), *record.get("deployerId"))) |
            
            for (a <- payRevReturnCh) {
              stdout!(4) |
              match *a {
                true => {
                  stdout!("success: record " ++ *record.get("name") ++ " created") |
                  return!(true) |
                  records!(*current.set(*record.get("name"), *record))
                }
                _ => {
                  stdout!("error: payment failure") |
                  return!("error: payment failure") |
                  records!(*current)
                }
              }
            }
          }
        }
      }
    }
  } |

  contract entry(@(action, return)) = {
    stdout!(action) |
    match action.get("type") {
      "CREATE" => {
        createCh!(action.get("payload"), return)
      }
      "UPDATE" => {
        updateCh!(action.get("payload"), return)
      }
      "CHANGE_PRICE" => {
        changePriceCh!(action.get("payload"), return)
      }
    }
  } |

  insertArbitrary!(*entry, *entryUriCh) |
  insertArbitrary!(*records, *recordsUriCh) |

  for (entryUri <- entryUriCh; recordsUri <- recordsUriCh) {
    stdout!({
      "entryRegistryUri": *entryUri,
      "recordsRegistryUri": *recordsUri,
      "recordsUnforgeableName": *records
    }) |
    basket!({
      "entryRegistryUri": *entryUri,
      "recordsRegistryUri": *recordsUri,
      "recordsUnforgeableName": *records
    })
  }
}
