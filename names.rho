new records, update, create, entry, hashname, verify, test, entryUriCh, updateUriCh, insertArbitrary(`rho:registry:insertArbitrary`), stdout(`rho:io:stdout`) in {

  // Send an initially empty map
  records!({}) |
  
  stdout!(*records) |

  // Update a record
  contract update(record, return) = {
    stdout!("update") |
    for (current <- records) {
      stdout!(*current) |
      match *current.contains(*record.get("name")) {
        true => {
          @"keccak256Hash"!(*record.get("name").toUtf8Bytes(), *hashname) |
          for (hash <- hashname) {
            stdout!(*hash) |
            // TODO improve the verify, not secure at all at the moment
            @"ed25519Verify"!(
              *hash,
              *record.get("signature").hexToBytes(),
              *current.get(*record.get("name")).get("publickey").hexToBytes(),
              *verify
            )
          } |
          for (verified <- verify) {
            match *verified {
              true => {
                return!("success: record updated") |
                records!(*current.set(*record.get("name"), *record))
              }
              false => {
                return!("error: invalid signature") |
                records!(*current)
              }
            }
          }
        }
        false => {
          return!("error: name not found") |
          records!(*current)
        }
      }
    }
  } |

  // create a record
  contract create(record, return) = {
    stdout!("create") |
    for (current <- records) {
      match *current.contains(*record.get("name")) {
      true => {
        return!("error: name " ++ *record.get("name") ++ " already taken") |
        records!(*current)
      }
      false => {
        return!("success: record " ++ *record.get("name") ++ " created") |
        records!(*current.set(*record.get("name"), *record))
      }}
    }
  } |

  contract entry(action, return) = {
    match *action.get("type") {
      "CREATE" => {
        create!(*action.get("payload"), *return)
      }
      "UPDATE" => {
        update!(*action.get("payload"), *return)
      }
    }
  } |

  insertArbitrary!(*entry, *entryUriCh) |
  for (uri <- entryUriCh) {
    stdout!(*uri)
  }
}
