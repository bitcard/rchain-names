new
  basket,
  records,
  recordsReaderCh,
  updateCh,
  createCh,
  changePriceCh,
  entry,
  entryUriCh,
  recordsUriCh,
  updateUriCh,
  priceNonceCh,
  publicKeyCh,
  recipientAddressCh,
  priceCh,
  rl(`rho:registry:lookup`),
  secpVerify(`rho:crypto:secp256k1Verify`),
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`),
  lookup(`rho:registry:lookup`),
  blake2b256(`rho:crypto:blake2b256Hash`)
in {

  // 1 REV
  priceCh!(100000000) |

  priceNonceCh!(NONCE) |
  publicKeyCh!(PUBLIC_KEY) |
  recipientAddressCh!(ADDRESS) |

  // Remove the following line (GENESIS_OPERATIONS) if you don't want prereserved names
  GENESIS_OPERATIONS
  records!({}) |

  // Change the price of record purchase
  contract changePriceCh(@payload, return) = {
    new hashCh, verifySignatureChangePriceCh in {
      for (@priceNonce <- priceNonceCh; @publicKey <- publicKeyCh) {
        publicKeyCh!(publicKey) |
        blake2b256!(
          priceNonce.toUtf8Bytes(),
          *hashCh
        ) |
        for (@hash <- hashCh) {
          secpVerify!(
            hash,
            payload.get("signature").hexToBytes(),
            publicKey.hexToBytes(),
            *verifySignatureChangePriceCh
          )
        } |
        for (@result <- verifySignatureChangePriceCh) {
          match result {
            true => {
              for (price <- priceCh) {
                stdout!("Price changed successfully to new value") |
                stdout!(payload.get("price")) |
                return!("Price changed successfully to new value") |
                priceCh!(payload.get("price")) |
                priceNonceCh!(payload.get("nonce"))
              }
            }
            false => {
              stdout!("error: Invalid signature, could not change price") |
              return!("error: Invalid signature, could not change price") |
              priceNonceCh!(priceNonce)
            }
          }
        }
      }
    }
  } |


  // Update a record
  contract updateCh(@record, return) = {
    new hashCh, verifySignatureCh in {
      for (current <- records) {
        match *current.contains(record.get("name")) {
          true => {
            match *current.get(record.get("name")) {
              registryUri => {
                new recordCh in {
                  lookup!(registryUri, *recordCh) |
                  for (currentRecord <- recordCh) {
                    blake2b256!(
                      *currentRecord.get("nonce").toUtf8Bytes(),
                      *hashCh
                    ) |
                    for (@hash <- hashCh) {
                      secpVerify!(
                        hash,
                        record.get("signature").hexToBytes(),
                        *currentRecord.get("publicKey").hexToBytes(),
                        *verifySignatureCh
                      ) |
                      for (@result <- verifySignatureCh) {
                        match result {
                          true => {
                            return!(true) |
                            new recordUriCh in {
                              insertArbitrary!(record, *recordUriCh) |
                              for (recordUri <- recordUriCh) {
                                records!(
                                  *current
                                    .delete(record.get("name"))
                                    .set(record.get("name"), *recordUri)
                                )
                              }
                            }
                          }
                          false => {
                            return!("error: signature invalid") |
                            records!(*current)
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          false => {
            return!("error: name not found") |
            records!(*current)
          }
        }
      }
    }
  } |

  // create a record
  contract createCh(record, return) = {
    for (current <- records) {
      match *current.contains(*record.get("name")) {
        true => {
          return!("error: name " ++ *record.get("name") ++ " already taken") |
          records!(*current)
        }
        false => {
          new payRevReturnCh,
            payRevDataCh,
            revVaultCh,
            revAddressCh,
            RevAddress(`rho:rev:address`)
          in {
            // Payment handling
            for (@(pubKey, deployerId) <- payRevDataCh) {

              RevAddress!("fromPublicKey", pubKey.hexToBytes(), *revAddressCh) |

              for (@revAddress <- revAddressCh; @price <- priceCh; @recipientAddress <- recipientAddressCh) {
                priceCh!(price) |
                recipientAddressCh!(recipientAddress) |
                rl!(`rho:rchain:revVault`, *revVaultCh) |
                for (@(_, RevVault) <- revVaultCh) {
                  new vaultCh, vaultTo, revVaultkeyCh,
                    deployId(`rho:rchain:deployId`)
                  in {
                    match (revAddress, recipientAddress, price) {
                      (revAddrFrom, revAddrTo, amount) => {
                        @RevVault!("findOrCreate", revAddrFrom, *vaultCh) |
                        @RevVault!("findOrCreate", revAddrTo, *vaultTo) |
                        @RevVault!("deployerAuthKey", deployerId, *revVaultkeyCh) |
                        for (@vault <- vaultCh; key <- revVaultkeyCh; _ <- vaultTo) {
                          match vault {
                            (true, vault) => {
                              new resultCh in {
                                @vault!("transfer", revAddrTo, amount, *key, *resultCh) |
                                for (@result <- resultCh) {

                                  match result {
                                    (true , Nil) =>  payRevReturnCh!(true)
                                    (false, err) => payRevReturnCh!(err)
                                  }
                                }
                              }
                            }
                            err => { payRevReturnCh!(err) }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } |

            payRevDataCh!((*record.get("publicKey"), *record.get("deployerId"))) |
            
            for (a <- payRevReturnCh) {
              match *a {
                true => {
                  new recordUriCh in {
                    insertArbitrary!(*record.delete("deployerId"), *recordUriCh) |
                    for (recordUri <- recordUriCh) {
                      stdout!("success: record " ++ *record.get("name") ++ " created") |
                      return!(true) |
                      records!(*current.set(*record.get("name"), *recordUri))
                    }
                  }
                }
                _ => {
                  stdout!("error: payment failure") |
                  return!("error: payment failure") |
                  records!(*current)
                }
              }
            }
          }
        }
      }
    }
  } |

  contract entry(@(action, return)) = {
    stdout!(action) |
    match action.get("type") {
      "CREATE" => {
        createCh!(action.get("payload"), return)
      }
      "UPDATE" => {
        updateCh!(action.get("payload"), return)
      }
      "CHANGE_PRICE" => {
        changePriceCh!(action.get("payload"), return)
      }
    }
  } |

  insertArbitrary!(*entry, *entryUriCh) |
  insertArbitrary!(*recordsReaderCh, *recordsUriCh) |

  for (ch <= recordsReaderCh) {
    for (current <<- records; priceNonce <<- priceNonceCh) {
      ch!({
        "records": *current,
        "priceNonce": *priceNonce
      })
    }
  } |

  for (entryUri <- entryUriCh; recordsUri <- recordsUriCh) {
    stdout!({
      "entryRegistryUri": *entryUri,
      "recordsRegistryUri": *recordsUri,
      "recordsUnforgeableName": *records
    }) |
    basket!({
      "entryRegistryUri": *entryUri,
      "recordsRegistryUri": *recordsUri,
      "recordsUnforgeableName": *records
    })
  }
}
